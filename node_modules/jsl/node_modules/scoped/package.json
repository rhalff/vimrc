{
  "name": "scoped",
  "version": "1.1.2",
  "description": "command line tool exposing lexical-scope",
  "main": "index.js",
  "scripts": {
    "test": "node test/index.js"
  },
  "bin": {
    "scoped": "./bin/scoped"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/chrisdickinson/scoped.git"
  },
  "keywords": [
    "detect",
    "scopes"
  ],
  "author": {
    "name": "Chris Dickinson",
    "email": "chris@neversaw.us"
  },
  "license": "MIT",
  "dependencies": {
    "optimist": "~0.3.5",
    "process": "~0.5.1",
    "cssauron-falafel": "0.0.3",
    "cssauron": "~0.2.1",
    "falafel": "~0.2.1",
    "ansicolors": "~0.2.1",
    "concat-stream": "~1.0.0"
  },
  "devDependencies": {
    "tape": "~1.0.4",
    "jsl": "0.0.5"
  },
  "readme": "# scoped\n\nscoped is a command line tool to help you reason about your javascript.\n\nscoped is also a library that will give you all of the scope information about\na given `falafel`-generated AST! (it even works with `let`!)\n\n```javascript\nvar scoped = require('scoped')\n  , falafel = require('falafel')\n\nfalafel('<some javascript>', scoped(function(scope) {\n    scope.vars                          // vars declared in this scope\n    scope.vars[0].name                  // the name of the var\n    scope.vars[0].nodes                 // a list of nodes + kinds of use\n    scope.vars[0].nodes[0].kind         // \"implicit\", \"explicit\", or \"declare\"\n    scope.vars[0].nodes[0].node         // the esprima AST node.\n\n    scope.children                      // the list of child scopes of this node\n    scope.children[0]                   // as an array.\n\n    scope.uses                          // the list of variables that this scope\n                                        // \"uses\" from parent scopes. at top level,\n                                        // these are globals.\n}))\n\n// you can also tell scoped to ignore certain globals:\nfalafel('<some javascript>', scoped(['Math', 'module'], function(scope) {\n\n}))\n\n```\n\nit notifies you of globals -- both explicit (created by assigning) and implicit\n(use without definition) -- and, when given a position in the file, will let you know\nwhat variables are in scope at that point.\n\n![example scoped output](http://cl.ly/image/0G2M2R0Z093N/scoped.png)\n\n# usage\n\n### scoped path/to/file.js\n\noutputs only global usage/leakage information, with line and column numbers.\n\n### scoped path/to/file.js --position=line[,column]\n\noutputs scope chain, with usage/definition for each scope. `position` is\nin the form `LINE,COLUMN`. `,COLUMN` may be omitted, if so, it is assumed\nto be `1`. Both `line` and `column` are assumed to be 1-indexed (like most\neditors).\n\n* Green `+` signs indicate scope definitions -- i.e., a new variable was created\n  in this scope.\n\n* Purple `*` signs indicate use of a variable from a containing scope.\n\n* If the function is named, it will use that to describe the function.\n\n# installation\n\n`npm install -g scoped`\n\n# license\n\nMIT \n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/chrisdickinson/scoped/issues"
  },
  "_id": "scoped@1.1.2",
  "dist": {
    "shasum": "d34f2ca8ae84c1202ae1f1b0d4f4eaa89145a51b"
  },
  "_from": "scoped@~1.1.2",
  "_resolved": "https://registry.npmjs.org/scoped/-/scoped-1.1.2.tgz"
}
