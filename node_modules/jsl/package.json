{
  "name": "jsl",
  "version": "0.0.10",
  "description": "a modular js linter",
  "main": "index.js",
  "scripts": {
    "test": "node test.js"
  },
  "bin": {
    "jsl": "./bin/jsl"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/chrisdickinson/jsl.git"
  },
  "keywords": [
    "lint",
    "linter",
    "code quality"
  ],
  "author": {
    "name": "Chris Dickinson",
    "email": "chris@neversaw.us"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/chrisdickinson/jsl/issues"
  },
  "dependencies": {
    "cssauron-falafel": "0.0.2",
    "falafel": "~0.2.1",
    "concat-stream": "~1.0.0",
    "through": "~2.3.4",
    "cssauron": "~0.2.0",
    "scoped": "~1.1.2",
    "module-deps": "~1.0.1"
  },
  "readme": "# jsl\n\nan esprima-based, modular linter. by default, it installs some comma-first\nrules, but it's designed to let you build your own linter easily.\n\n# api\n\n### lint = require('linter')\n### lint() -> Linter\n\ncreate a new linter.\n\n### Linter.rule(selectNodeFunction, handleNodeFunction, errorLevel) -> Linter\n\n`selectNodeFunction :: Function(AST Node) -> Boolean` -- determines whether to run\n`handleNodeFunction` on a given node, \"selecting\" the node. `selectNodeFunction`\nmay also be a [CSSauron-Falafel](http://npm.im/cssauron-falafel) style selector\nstring.\n\n```javascript\nvar lint = require('jsl')\n  , linter\n\nlinter = lint()\n\nlinter.rule(function(node) { return !!node.params }, ..., 'error')\nlinter.rule('function > block > expr:first-child:last-child', ..., 'warn') \n```\n\n`handleNodeFunction :: Function(AST Node, subsourceFunction, alertFunction)` -- \nonce a node has been selected, determine whether or the node fails any style\nchecks. It receives the node in question, as well as a `subsource` function and\nan `alert` function. `alert` produces messages at the selected error level, while\nsubsource makes it easy to select ranges of strings while ignoring comments between\nnodes.\n\n```javascript\nvar lint = require('jsl')\n  , linter\n\nlinter = lint()\n\nlinter.rule('array', function(node, subsource, alert) {\n  var sub = subsource(node)\n    , src\n\n  // given `[a, b, c]`, `sub` will select:\n  //          ^^\n  // and return ', '.\n  src = sub(node.elements[0].range[1], node.elements[1].range[0])\n\n  // alert takes a node on which to attach the \n  // notification; a format string, and subsequent\n  // arguments to place into the format string.\n  alert(node, 'saw %r', src) \n}, 'general info')\n\n```\n\n### Linter.rule(handleNodeFunction, errorLevel) -> Linter \n\nIf `handleNodeFunction` has a **`.selector`** property, it will be used.\n\nThis is primarily to enable simple `require`'s.\n\n```javascript\n// linter.js\n\nlinter.rule(require('./contrived-test'), 'warning')\n\n// contrived-test.js\n\nmodule.exports = contrived\n\n// select the right descendant of any binary\n// operator:\ncontrived.selector = 'binary > * + *'\n\nfunction contrived(node, subsource, alert) {\n  alert(node, 'never use binary expressions because reasons')\n}\n```\n\n### Linter.line(handleLineFunction, errorLevel) -> Linter\n\nHandle a line of the file as a simple text chunk.\n\n```javascript\n\nlinter.line(function(line_number, line_string, alert) {\n  if(line_string.length > 80) {\n    alert('this line is too long.')\n  }\n}, 'error')\n\n```\n\n### Linter() -> linterStream()\n\nBy invoking `Linter`, you receive a through stream that takes file data\nand emits messages:\n\n```javascript\n{ type: String // \"level\" that the rule was assigned when given to the linter\n, line: Number\n, col: Number\n, message: String // the message emitted\n}\n```\n\n### Linter.cli()\n\nRun the linter as a CLI. The CLI will accept any number of files, run the linter on\nthem, and output messages. If rules with a level of `\"error\"` emit messages, the\nCLI will exit with a non-zero exit code.\n\n\n### Linter.test(fileList[, readyCallback]) -> Function\n\nGiven an array of entry points, create a function that takes `assert` and runs\nthe linter against your repository.\n\n```javascript\nvar test = require('tape')\n  , your_rules = require('your-rules')\n\ntest('repository lints', your_rules.test([__filename])) \n\n```\n\n### Linter.transform()\n\n**TODO**\n\nInstall a browserify transform that lints files as they come through, and if there\nare style violations, emits errors and halts compilation (borrowing a page from Go's\nbook).\n\n# license\n\nMIT\n",
  "readmeFilename": "README.md",
  "_id": "jsl@0.0.10",
  "dist": {
    "shasum": "b213980f55356f1fb8efaacfc7098b716326e095"
  },
  "_from": "jsl@",
  "_resolved": "https://registry.npmjs.org/jsl/-/jsl-0.0.10.tgz"
}
